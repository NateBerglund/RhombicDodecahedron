clear all
close all
clc

outputFolder = 'C:\Users\info\source\repos\RhombicDodecahedron';
outputFile = 'RhombicDodecahedraSpiral.stl';

freq = 6;
scale = 0.5;
translation = 36;
rBeg = -3;
rEnd = 36;
baseThickness = 3;

baseVertices = [...
6.0 6*sqrt(2) 6*sqrt(2);...
-6.0 6*sqrt(2) 6*sqrt(2);...
0.0 6*sqrt(2) 0.0;...
...
-6.0 -6*sqrt(2) 6*sqrt(2);...
6.0 -6*sqrt(2) 6*sqrt(2);...
0.0 -6*sqrt(2) 0.0;...
...
-6.0 6*sqrt(2) 6*sqrt(2);...
-6.0 0.0 0.0;...
0.0 6*sqrt(2) 0.0;...
...
-6.0 0.0 0.0;...
-6.0 6*sqrt(2) 6*sqrt(2);...
-12.000 0.0 6*sqrt(2);...
...
-6.0 -6*sqrt(2) 6*sqrt(2);...
-6.0 0.0 0.0;...
-12.000 0.0 6*sqrt(2);...
...
-6.0 0.0 0.0;...
-6.0 -6*sqrt(2) 6*sqrt(2);...
0.0 -6*sqrt(2) 0.0;...
...
6.0 6*sqrt(2) 6*sqrt(2);...     
0.0 6*sqrt(2) 0.0;...
6.0 0.0 0.0;...
...
6.0 0.0 0.0;...
12.000 0.0 6*sqrt(2);...
6.0 6*sqrt(2) 6*sqrt(2);...
...
6.0 -6*sqrt(2) 6*sqrt(2);... 
12.000 0.0 6*sqrt(2);...
6.0 0.0 0.0;...
...
6.0 0.0 0.0;...
0.0 -6*sqrt(2) 0.0;...
6.0 -6*sqrt(2) 6*sqrt(2)];

baseVertices2 = baseVertices;

% Orientation flip
temp = baseVertices(1:3:end,:);
baseVertices(1:3:end,:) = baseVertices(2:3:end,:);
baseVertices(2:3:end,:) = temp;

% reflect and concatenate
baseVertices2(:,3) = 12*sqrt(2) - baseVertices2(:,3);
baseVertices = [baseVertices; baseVertices2];

baseVertices = [baseVertices;...
0.0 6*sqrt(2) 12*sqrt(2);...
-6.0 0.0 12*sqrt(2);...
6.0 0.0 12*sqrt(2);...
...
-6.0 0.0 12*sqrt(2);...
0.0 -6*sqrt(2) 12*sqrt(2);...
6.0 0.0 12*sqrt(2);...
];

baseVerticesFlat = [...
0.0 6*sqrt(2) 0;...
-6.0 0.0 0;...
6.0 0.0 0;...
...
-6.0 0.0 0;...
0.0 -6*sqrt(2) 0;...
6.0 0.0 0;...
];

% Add radial fill
fillVertices = [...
6 0 0;...
(translation-6)/scale - translation 0 0;...
0 6*sqrt(2) 0;...
...
0 6*sqrt(2) 0;...
(translation-6)/scale - translation 0 0;...
translation/scale - translation 6*sqrt(2)/scale 0;...
...
(translation-6)/scale - translation 0 0;...
6 0 0;...
0 -6*sqrt(2) 0;...
...
(translation-6)/scale - translation 0 0;...
0 -6*sqrt(2) 0;...
translation/scale - translation -6*sqrt(2)/scale 0;...
];

% Add transverse fill
r = -1;
scalar = power(scale, r/freq);
theta = 2*r*pi/freq;
rotMatrix = [
  cos(theta) -sin(theta) 0; ...
  sin(theta) cos(theta) 0; ...
  0 0 1];
fillVertices = [fillVertices;...
translation/scale - translation -6*sqrt(2)/scale 0;...
0 -6*sqrt(2) 0;...
[translation*scalar scalar*6*sqrt(2) 0] * rotMatrix' - [translation 0 0];...
...
translation/scale - translation -6*sqrt(2)/scale 0;...
[translation*scalar scalar*6*sqrt(2) 0] * rotMatrix' - [translation 0 0];...
[translation*scalar + (translation/scale - translation)*scalar...
  6*sqrt(2)*scalar/scale...
  0] * rotMatrix' - [translation 0 0];...
];

% Border fill
fillVerticesBorder_RInner = [...
6 0 0;...
0 6*sqrt(2) 0;...
6 0 -baseThickness;...
...
6 0 -baseThickness;...
0 6*sqrt(2) 0;...
0 6*sqrt(2) -baseThickness;...
...
0 -6*sqrt(2) 0;...
6 0 0;...
0 -6*sqrt(2) -baseThickness;...
...
0 -6*sqrt(2) -baseThickness;...
6 0 0;...
6 0 -baseThickness;...
];

fillVerticesBorder_TInner = [...
0 -6*sqrt(2) 0;...
0 -6*sqrt(2) -baseThickness;...
[translation*scalar scalar*6*sqrt(2) 0] * rotMatrix' - [translation 0 0];...
...
[translation*scalar scalar*6*sqrt(2) 0] * rotMatrix' - [translation 0 0];...
0 -6*sqrt(2) -baseThickness;...
[translation*scalar scalar*6*sqrt(2) 0] * rotMatrix' - [translation 0 baseThickness];...
];

fillVerticesBorder_ROuter = [...
translation/scale - translation 6*sqrt(2)/scale 0;...
(translation-6)/scale - translation 0 0;...
(translation-6)/scale - translation 0 -baseThickness;...
...
translation/scale - translation 6*sqrt(2)/scale 0;...
(translation-6)/scale - translation 0 -baseThickness;...
translation/scale - translation 6*sqrt(2)/scale -baseThickness;...
...
(translation-6)/scale - translation 0 0;...
translation/scale - translation -6*sqrt(2)/scale 0;...
translation/scale - translation -6*sqrt(2)/scale -baseThickness;...
...
(translation-6)/scale - translation 0 0;...
translation/scale - translation -6*sqrt(2)/scale -baseThickness;...
(translation-6)/scale - translation 0 -baseThickness;...
];

fillVerticesBorder_TOuter = [...
translation/scale - translation -6*sqrt(2)/scale -baseThickness;...
translation/scale - translation -6*sqrt(2)/scale 0;...
[translation*scalar + (translation/scale - translation)*scalar...
  6*sqrt(2)*scalar/scale...
  0] * rotMatrix' - [translation 0 0];...
...
translation/scale - translation -6*sqrt(2)/scale -baseThickness;...
[translation*scalar + (translation/scale - translation)*scalar...
  6*sqrt(2)*scalar/scale...
  0] * rotMatrix' - [translation 0 0];...
[translation*scalar + (translation/scale - translation)*scalar...
  6*sqrt(2)*scalar/scale...
  0] * rotMatrix' - [translation 0 baseThickness];...
];

fid = fopen([outputFolder '\' outputFile],'wt');
fprintf(fid, 'solid rhombicDodecahedraFlatBase\n');

% Main pattern
for r=rBeg:rEnd
  theta = 2*r*pi/freq;
  rotMatrix = [
    cos(theta) -sin(theta) 0; ...
    sin(theta) cos(theta) 0; ...
    0 0 1];
  scalar = power(scale, r/freq);
  
  vertices = fillVertices;
  if (r <= rEnd-freq)
    vertices = [vertices;...
    baseVertices...
    ];
  endif
  
  vertices = scalar * vertices;
  vertices = vertices  + ones(size(vertices,1),1) * ...
    [translation*scalar 0 0];
    
  vertices = vertices * rotMatrix';
  
  for f = 1:(size(vertices,1)/3)
    fprintf(fid, 'facet normal 0.0 0.0 1.0\n');
    fprintf(fid, '    outer loop\n');
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', vertices(3*f-2,:));
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', vertices(3*f-1,:));
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', vertices(3*f,:));
    fprintf(fid, '    endloop\n');
    fprintf(fid, 'endfacet\n');
  end
end

% Base bottom
for r=rBeg:rEnd
  theta = 2*r*pi/freq;
  rotMatrix = [
    cos(theta) -sin(theta) 0; ...
    sin(theta) cos(theta) 0; ...
    0 0 1];  
  scalar = power(scale, r/freq);
  
  vertices = fillVertices;
  if (r <= rEnd-freq)
    vertices = [vertices; baseVerticesFlat];
  endif
 
  vertices = scalar * vertices;
  vertices = vertices  + ones(size(vertices,1),1) * ...
    [translation*scalar 0 0];
    
  vertices = vertices * rotMatrix';
  
  vertices(:,3) = -baseThickness;
  
  for f = 1:(size(vertices,1)/3)
    fprintf(fid, 'facet normal 0.0 0.0 1.0\n');
    fprintf(fid, '    outer loop\n');
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', vertices(3*f-2,:));
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', vertices(3*f-1,:));
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', vertices(3*f,:));
    fprintf(fid, '    endloop\n');
    fprintf(fid, 'endfacet\n');
  end
end

% Border
for r=rBeg:rEnd
  theta = 2*r*pi/freq;
  rotMatrix = [
    cos(theta) -sin(theta) 0; ...
    sin(theta) cos(theta) 0; ...
    0 0 1];  
  scalar = power(scale, r/freq);
  
  vertices = zeros(0,3);
  if (r > rEnd - freq)
    vertices = [vertices;...
    fillVerticesBorder_RInner;...
    fillVerticesBorder_TInner];
  endif
  if (r < rBeg + freq)
    vertices = [vertices;...
    fillVerticesBorder_ROuter;...
    fillVerticesBorder_TOuter];
  endif
   
  vertices = scalar * vertices;
  vertices = vertices  + ones(size(vertices,1),1) * ...
    [translation*scalar 0 0];
    
  vertices = vertices * rotMatrix';
  
  zValues = vertices(:,3);
  zValues(zValues < 0) = -baseThickness;
  vertices(:,3) = zValues;
  
  for f = 1:(size(vertices,1)/3)
    fprintf(fid, 'facet normal 0.0 0.0 1.0\n');
    fprintf(fid, '    outer loop\n');
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', vertices(3*f-2,:));
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', vertices(3*f-1,:));
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', vertices(3*f,:));
    fprintf(fid, '    endloop\n');
    fprintf(fid, 'endfacet\n');
  end
end

fprintf(fid, 'endsolid\n');
fclose(fid);

